import { Resource } from "src/definitions/resources";
import structureDefinitions, { Structure } from "src/definitions/structures";
import { ResourceStructureDefinition, ResourceStructureLevelDefinition, StructureDefinition, StructureType, WarehouseStructureDefinition, WarehouseStructureLevelDefinition } from "src/definitions/structures/types";
import { StoreState } from "src/stores";
import { ResourceStoreState } from "src/stores/resources";
import { StructuresStoreState } from "src/stores/structures";

const RESOURCE_INTERVAL = 60000; // every minute constitutes a resource tick. todo: move to some other shared place

 /*
  * Calculates how many resources are generated by the in the town.
  * Will return a ResourceStoreState with the amount of each resource to add  */
const getProducedResources = (delta: number, store: StoreState) => {
    const structures: StructuresStoreState = store.structures;
    const result: ResourceStoreState = {};
    const factor = delta / RESOURCE_INTERVAL;
    // this function can run at different intervals
    // faster or slower than once a minute
    // we will multiply the resource amount by the factor to normalize
    const maxResources = getMaxResources(store);

    const handleStructure = (structure: string) => {
        const structureDefinition: StructureDefinition = structureDefinitions[structure];

        if (structureDefinition.type === StructureType.resource) {
            const resourceStructureDefinition = structureDefinition as ResourceStructureDefinition;
            const level: number = structures[structure].level;
            const levelDefinition: ResourceStructureLevelDefinition = resourceStructureDefinition.levels[level];

            // Store all the resources that this structure will generate this tick into `result`
            Object.keys(levelDefinition.generates).reduce((accumulator: ResourceStoreState, resource: string) => {
                const amount: number = levelDefinition.generates[resource] * structures[structure].workers * factor;
                accumulator[resource] = (accumulator[resource] || 0) + amount;
                return accumulator;
            }, result);
        }
    };

    // Calculate what each structure generates. Stores in `result`.
    Object.keys(structures).forEach((structure) => handleStructure(structure));

    // Check if the warehouse can actually hold it
    // todo: [10/07/2019] move to reducer
    Object.keys(result).forEach((resource: Resource) => {
        if (result[resource]) {
            if (store.resources[resource]! + result[resource]! >= maxResources[resource]!) {
                result[resource] = maxResources[resource]! - (store.resources[resource]!);
            }
        }
//        console.log(`Adding: ${resource} ${result[resource]}`);
    });

    return result;
};

// Returns a ResourceStoreState with maximum stockpile of each resource the warehouse supports
const getMaxResources = (store: StoreState): ResourceStoreState => {
    const structureDefinition = structureDefinitions[Structure.warehouse] as WarehouseStructureDefinition;
    const level: number = store.structures[Structure.warehouse].level;
    const levelDefinition: WarehouseStructureLevelDefinition = structureDefinition.levels[level];
    return levelDefinition.maxResources;
};

export default getProducedResources;
