import { getDefinition, Structure } from "definitions/structures";
import { ResourceStructureDefinition, ResourceStructureLevelDefinition, StructureDefinition, StructureType, WarehouseStructureDefinition, WarehouseStructureLevelDefinition } from "definitions/structures/types";
import { StoreState } from "stores";
import { ResourceStoreState } from "stores/resources";
import { StructuresStoreState } from "stores/structures";

//const RESOURCE_INTERVAL = 60000; // every minute constitutes a resource tick. todo: move to some other shared place
const RESOURCE_INTERVAL = 20000; // every thirty seconds constitutes a resource tick. todo: move to some other shared place

 /*
  * Calculates how many resources are generated by the in the town.
  * Will return a ResourceStoreState with the amount of each resource to add  */
const getProducedResources = (lastProducedUpdate: number, store: StoreState): ResourceStoreState|null => {
    const structures: StructuresStoreState = store.structures;
    const result: ResourceStoreState = {};
    const factor = ((Date.now() - lastProducedUpdate) / RESOURCE_INTERVAL);

    // this function can run at different intervals
    // faster or slower than once a minute
    // we will multiply the resource amount by the factor to normalize
    const maxResources = getMaxResources(store);

    const handleStructure = (structure: string) => {
        const structureDefinition = getDefinition(structure);

        if (structureDefinition.type === StructureType.resource) {
            const resourceStructureDefinition = structureDefinition as ResourceStructureDefinition;
            const level: number = structures[structure].level;
            const levelDefinition: ResourceStructureLevelDefinition = resourceStructureDefinition.levels[level];

            // Store all the resources that this structure will generate this tick into `result`
            Object.keys(levelDefinition.generates).reduce((accumulator: ResourceStoreState, resource: string) => {
                const amount: number = levelDefinition.generates[resource] * structures[structure].workers * factor;
                accumulator[resource] = (accumulator[resource] || 0) + amount;
                return accumulator;
            }, result);
        }
    };

    if (factor < 1) {
        return null;
    }
    // Calculate what each structure generates. Stores in `result`.
    Object.keys(structures).forEach((structure) => handleStructure(structure));

    // Check if the warehouse can actually hold it
    Object.keys(result).forEach((resource: string) => {
        if (result[resource]) {
            if (store.resources[resource]! + result[resource]! >= maxResources[resource]!) {
                result[resource] = maxResources[resource]! - (store.resources[resource]!);
            }
        }
        //console.log(`Adding: ${resource} ${result[resource]} factor ${factor}`);
    });

    return result;
};

// Returns a ResourceStoreState with maximum stockpile of each resource the warehouse supports
const getMaxResources = (store: StoreState): ResourceStoreState => {
    const structureDefinition = getDefinition<WarehouseStructureDefinition>(Structure.warehouse);
    const level: number = store.structures[Structure.warehouse].level;
    const levelDefinition: WarehouseStructureLevelDefinition = structureDefinition.levels[level];
    return levelDefinition.maxResources;
};

export default getProducedResources;
